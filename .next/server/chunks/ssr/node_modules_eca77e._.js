module.exports = {

"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports._ = _interop_require_default;
}}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}}),
"[project]/node_modules/zustand/esm/vanilla.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createStore": (()=>createStore)
});
const createStoreImpl = (createState)=>{
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace)=>{
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
            const previousState = state;
            state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
            listeners.forEach((listener)=>listener(state, previousState));
        }
    };
    const getState = ()=>state;
    const getInitialState = ()=>initialState;
    const subscribe = (listener)=>{
        listeners.add(listener);
        return ()=>listeners.delete(listener);
    };
    const api = {
        setState,
        getState,
        getInitialState,
        subscribe
    };
    const initialState = state = createState(setState, getState, api);
    return api;
};
const createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;
;
}}),
"[project]/node_modules/zustand/esm/react.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "create": (()=>create),
    "useStore": (()=>useStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/zustand/esm/vanilla.mjs [app-ssr] (ecmascript)");
;
;
const identity = (arg)=>arg;
function useStore(api, selector = identity) {
    const slice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].useSyncExternalStore(api.subscribe, ()=>selector(api.getState()), ()=>selector(api.getInitialState()));
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].useDebugValue(slice);
    return slice;
}
const createImpl = (createState)=>{
    const api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createStore"])(createState);
    const useBoundStore = (selector)=>useStore(api, selector);
    Object.assign(useBoundStore, api);
    return useBoundStore;
};
const create = (createState)=>createState ? createImpl(createState) : createImpl;
;
}}),
"[project]/node_modules/regenerator-runtime/runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var runtime = function(exports) {
    "use strict";
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
    };
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        return obj[key];
    }
    try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
    } catch (err) {
        define = function(obj, key, value) {
            return obj[key] = value;
        };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self, context)
        });
        return generator;
    }
    exports.wrap = wrap;
    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};
    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
    });
    defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
    });
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }
    exports.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
    };
    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
        return {
            __await: arg
        };
    };
    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
                reject(record.arg);
            } else {
                var result = record.arg;
                var value = result.value;
                if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                    return PromiseImpl.resolve(value.__await).then(function(value) {
                        invoke("next", value, resolve, reject);
                    }, function(err) {
                        invoke("throw", err, resolve, reject);
                    });
                }
                return PromiseImpl.resolve(value).then(function(unwrapped) {
                    // When a yielded Promise is resolved, its final value becomes
                    // the .value of the Promise<{value,done}> result for the
                    // current iteration.
                    result.value = unwrapped;
                    resolve(result);
                }, function(error) {
                    // If a rejected Promise was yielded, throw the rejection back
                    // into the async generator function so it can be handled there.
                    return invoke("throw", error, resolve, reject);
                });
            }
        }
        var previousPromise;
        function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        defineProperty(this, "_invoke", {
            value: enqueue
        });
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    });
    exports.AsyncIterator = AsyncIterator;
    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
         : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    };
    function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
            if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
                if (method === "throw") {
                    throw arg;
                }
                // Be forgiving, per GeneratorResume behavior specified since ES2015:
                // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume
                // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume
                return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while(true){
                var delegate = context.delegate;
                if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                    }
                }
                if (context.method === "next") {
                    // Setting context._sent for legacy support of Babel's
                    // function.sent implementation.
                    context.sent = context._sent = context.arg;
                } else if (context.method === "throw") {
                    if (state === GenStateSuspendedStart) {
                        state = GenStateCompleted;
                        throw context.arg;
                    }
                    context.dispatchException(context.arg);
                } else if (context.method === "return") {
                    context.abrupt("return", context.arg);
                }
                state = GenStateExecuting;
                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                    // If an exception is thrown from innerFn, we leave state ===
                    // GenStateExecuting and loop back for another invocation.
                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                    if (record.arg === ContinueSentinel) {
                        continue;
                    }
                    return {
                        value: record.arg,
                        done: context.done
                    };
                } else if (record.type === "throw") {
                    state = GenStateCompleted;
                    // Dispatch the exception by looping back around to the
                    // context.dispatchException(context.arg) call above.
                    context.method = "throw";
                    context.arg = record.arg;
                }
            }
        };
    }
    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined) {
            // A .throw or .return when the delegate iterator has no .throw
            // method, or a missing .next method, always terminate the
            // yield* loop.
            context.delegate = null;
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (methodName === "throw" && delegate.iterator["return"]) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = "return";
                context.arg = undefined;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw") {
                    // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel;
                }
            }
            if (methodName !== "return") {
                context.method = "throw";
                context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
        }
        if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value;
            // Resume execution at the desired location (see delegateYield).
            context.next = delegate.nextLoc;
            // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.
            if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined;
            }
        } else {
            // Re-yield the result returned by the delegate method.
            return info;
        }
        // The delegate iterator is finished, so forget it and continue with
        // the outer generator.
        context.delegate = null;
        return ContinueSentinel;
    }
    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    define(Gp, iteratorSymbol, function() {
        return this;
    });
    define(Gp, "toString", function() {
        return "[object Generator]";
    });
    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        if (1 in locs) {
            entry.catchLoc = locs[1];
        }
        if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
    }
    function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
    }
    exports.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for(var key in object){
            keys.push(key);
        }
        keys.reverse();
        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
            while(keys.length){
                var key = keys.pop();
                if (key in object) {
                    next.value = key;
                    next.done = false;
                    return next;
                }
            }
            // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.
            next.done = true;
            return next;
        };
    };
    function values(iterable) {
        if (iterable != null) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
                return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
                return iterable;
            }
            if (!isNaN(iterable.length)) {
                var i = -1, next = function next() {
                    while(++i < iterable.length){
                        if (hasOwn.call(iterable, i)) {
                            next.value = iterable[i];
                            next.done = false;
                            return next;
                        }
                    }
                    next.value = undefined;
                    next.done = true;
                    return next;
                };
                return next.next = next;
            }
        }
        throw new TypeError(typeof iterable + " is not iterable");
    }
    exports.values = values;
    function doneResult() {
        return {
            value: undefined,
            done: true
        };
    }
    Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.
            this.sent = this._sent = undefined;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
                for(var name in this){
                    // Not sure about the optimal order of these conditions:
                    if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                        this[name] = undefined;
                    }
                }
            }
        },
        stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
                throw rootRecord.arg;
            }
            return this.rval;
        },
        dispatchException: function(exception) {
            if (this.done) {
                throw exception;
            }
            var context = this;
            function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;
                if (caught) {
                    // If the dispatched exception was caught by a catch block,
                    // then let that catch block handle the exception normally.
                    context.method = "next";
                    context.arg = undefined;
                }
                return !!caught;
            }
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                var record = entry.completion;
                if (entry.tryLoc === "root") {
                    // Exception thrown outside of any try block that could handle
                    // it, so set the completion value of the entire function to
                    // throw the exception.
                    return handle("end");
                }
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc");
                    var hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) {
                            return handle(entry.catchLoc, true);
                        } else if (this.prev < entry.finallyLoc) {
                            return handle(entry.finallyLoc);
                        }
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) {
                            return handle(entry.catchLoc, true);
                        }
                    } else if (hasFinally) {
                        if (this.prev < entry.finallyLoc) {
                            return handle(entry.finallyLoc);
                        }
                    } else {
                        throw new Error("try statement without catch or finally");
                    }
                }
            }
        },
        abrupt: function(type, arg) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
            }
            return this.complete(record);
        },
        complete: function(record, afterLoc) {
            if (record.type === "throw") {
                throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
                this.next = record.arg;
            } else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
            }
            return ContinueSentinel;
        },
        finish: function(finallyLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                    this.complete(entry.completion, entry.afterLoc);
                    resetTryEntry(entry);
                    return ContinueSentinel;
                }
            }
        },
        "catch": function(tryLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if (record.type === "throw") {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.
            throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            };
            if (this.method === "next") {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined;
            }
            return ContinueSentinel;
        }
    };
    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;
}(// If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
("TURBOPACK compile-time truthy", 1) ? module.exports : ("TURBOPACK unreachable", undefined));
try {
    regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
    } else {
        Function("r", "regeneratorRuntime = r")(runtime);
    }
}
}}),
"[project]/node_modules/react-speech-recognition/lib/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.browserSupportsPolyfills = exports.compareTwoStringsUsingDiceCoefficient = exports.commandToRegExp = exports.concatTranscripts = exports.debounce = void 0;
var debounce = function debounce(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this;
        var args = arguments;
        var later = function later() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};
exports.debounce = debounce;
var concatTranscripts = function concatTranscripts() {
    for(var _len = arguments.length, transcriptParts = new Array(_len), _key = 0; _key < _len; _key++){
        transcriptParts[_key] = arguments[_key];
    }
    return transcriptParts.map(function(t) {
        return t.trim();
    }).join(' ').trim();
}; // The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.
exports.concatTranscripts = concatTranscripts;
var optionalParam = /\s*\((.*?)\)\s*/g;
var optionalRegex = /(\(\?:[^)]+\))\?/g;
var namedParam = /(\(\?)?:\w+/g;
var splatParam = /\*/g;
var escapeRegExp = /[-{}[\]+?.,\\^$|#]/g;
var commandToRegExp = function commandToRegExp(command) {
    if (command instanceof RegExp) {
        return new RegExp(command.source, 'i');
    }
    command = command.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function(match, optional) {
        return optional ? match : '([^\\s]+)';
    }).replace(splatParam, '(.*?)').replace(optionalRegex, '\\s*$1?\\s*');
    return new RegExp('^' + command + '$', 'i');
}; // this is from https://github.com/aceakash/string-similarity
exports.commandToRegExp = commandToRegExp;
var compareTwoStringsUsingDiceCoefficient = function compareTwoStringsUsingDiceCoefficient(first, second) {
    first = first.replace(/\s+/g, '').toLowerCase();
    second = second.replace(/\s+/g, '').toLowerCase();
    if (!first.length && !second.length) return 1; // if both are empty strings
    if (!first.length || !second.length) return 0; // if only one is empty string
    if (first === second) return 1; // identical
    if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings
    if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string
    var firstBigrams = new Map();
    for(var i = 0; i < first.length - 1; i++){
        var bigram = first.substring(i, i + 2);
        var count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;
        firstBigrams.set(bigram, count);
    }
    var intersectionSize = 0;
    for(var _i = 0; _i < second.length - 1; _i++){
        var _bigram = second.substring(_i, _i + 2);
        var _count = firstBigrams.has(_bigram) ? firstBigrams.get(_bigram) : 0;
        if (_count > 0) {
            firstBigrams.set(_bigram, _count - 1);
            intersectionSize++;
        }
    }
    return 2.0 * intersectionSize / (first.length + second.length - 2);
};
exports.compareTwoStringsUsingDiceCoefficient = compareTwoStringsUsingDiceCoefficient;
var browserSupportsPolyfills = function browserSupportsPolyfills() {
    return typeof window !== 'undefined' && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);
};
exports.browserSupportsPolyfills = browserSupportsPolyfills;
}}),
"[project]/node_modules/react-speech-recognition/lib/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APPEND_TRANSCRIPT = exports.CLEAR_TRANSCRIPT = void 0;
var CLEAR_TRANSCRIPT = 'CLEAR_TRANSCRIPT';
exports.CLEAR_TRANSCRIPT = CLEAR_TRANSCRIPT;
var APPEND_TRANSCRIPT = 'APPEND_TRANSCRIPT';
exports.APPEND_TRANSCRIPT = APPEND_TRANSCRIPT;
}}),
"[project]/node_modules/react-speech-recognition/lib/actions.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.appendTranscript = exports.clearTranscript = void 0;
var _constants = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/constants.js [app-ssr] (ecmascript)");
var clearTranscript = function clearTranscript() {
    return {
        type: _constants.CLEAR_TRANSCRIPT
    };
};
exports.clearTranscript = clearTranscript;
var appendTranscript = function appendTranscript(interimTranscript, finalTranscript) {
    return {
        type: _constants.APPEND_TRANSCRIPT,
        payload: {
            interimTranscript: interimTranscript,
            finalTranscript: finalTranscript
        }
    };
};
exports.appendTranscript = appendTranscript;
}}),
"[project]/node_modules/react-speech-recognition/lib/reducers.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transcriptReducer = void 0;
var _constants = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/constants.js [app-ssr] (ecmascript)");
var _utils = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/utils.js [app-ssr] (ecmascript)");
var transcriptReducer = function transcriptReducer(state, action) {
    switch(action.type){
        case _constants.CLEAR_TRANSCRIPT:
            return {
                interimTranscript: '',
                finalTranscript: ''
            };
        case _constants.APPEND_TRANSCRIPT:
            return {
                interimTranscript: action.payload.interimTranscript,
                finalTranscript: (0, _utils.concatTranscripts)(state.finalTranscript, action.payload.finalTranscript)
            };
        default:
            throw new Error();
    }
};
exports.transcriptReducer = transcriptReducer;
}}),
"[project]/node_modules/react-speech-recognition/lib/isAndroid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _default = function _default() {
    return /(android)/i.test(typeof navigator !== 'undefined' ? navigator.userAgent : '');
};
exports["default"] = _default;
}}),
"[project]/node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = exports.isNative = void 0;
var NativeSpeechRecognition = typeof window !== 'undefined' && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);
var isNative = function isNative(SpeechRecognition) {
    return SpeechRecognition === NativeSpeechRecognition;
};
exports.isNative = isNative;
var _default = NativeSpeechRecognition;
exports["default"] = _default;
}}),
"[project]/node_modules/react-speech-recognition/lib/RecognitionManager.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _isAndroid = _interopRequireDefault(__turbopack_require__("[project]/node_modules/react-speech-recognition/lib/isAndroid.js [app-ssr] (ecmascript)"));
var _utils = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/utils.js [app-ssr] (ecmascript)");
var _NativeSpeechRecognition = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js [app-ssr] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var RecognitionManager = /*#__PURE__*/ function() {
    function RecognitionManager(SpeechRecognition) {
        _classCallCheck(this, RecognitionManager);
        this.recognition = null;
        this.pauseAfterDisconnect = false;
        this.interimTranscript = '';
        this.finalTranscript = '';
        this.listening = false;
        this.isMicrophoneAvailable = true;
        this.subscribers = {};
        this.onStopListening = function() {};
        this.previousResultWasFinalOnly = false;
        this.resetTranscript = this.resetTranscript.bind(this);
        this.startListening = this.startListening.bind(this);
        this.stopListening = this.stopListening.bind(this);
        this.abortListening = this.abortListening.bind(this);
        this.setSpeechRecognition = this.setSpeechRecognition.bind(this);
        this.disableRecognition = this.disableRecognition.bind(this);
        this.setSpeechRecognition(SpeechRecognition);
        if ((0, _isAndroid["default"])()) {
            this.updateFinalTranscript = (0, _utils.debounce)(this.updateFinalTranscript, 250, true);
        }
    }
    _createClass(RecognitionManager, [
        {
            key: "setSpeechRecognition",
            value: function setSpeechRecognition(SpeechRecognition) {
                var browserSupportsRecogniser = !!SpeechRecognition && ((0, _NativeSpeechRecognition.isNative)(SpeechRecognition) || (0, _utils.browserSupportsPolyfills)());
                if (browserSupportsRecogniser) {
                    this.disableRecognition();
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = true;
                    this.recognition.onresult = this.updateTranscript.bind(this);
                    this.recognition.onend = this.onRecognitionDisconnect.bind(this);
                    this.recognition.onerror = this.onError.bind(this);
                }
                this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);
            }
        },
        {
            key: "subscribe",
            value: function subscribe(id, callbacks) {
                this.subscribers[id] = callbacks;
            }
        },
        {
            key: "unsubscribe",
            value: function unsubscribe(id) {
                delete this.subscribers[id];
            }
        },
        {
            key: "emitListeningChange",
            value: function emitListeningChange(listening) {
                var _this = this;
                this.listening = listening;
                Object.keys(this.subscribers).forEach(function(id) {
                    var onListeningChange = _this.subscribers[id].onListeningChange;
                    onListeningChange(listening);
                });
            }
        },
        {
            key: "emitMicrophoneAvailabilityChange",
            value: function emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {
                var _this2 = this;
                this.isMicrophoneAvailable = isMicrophoneAvailable;
                Object.keys(this.subscribers).forEach(function(id) {
                    var onMicrophoneAvailabilityChange = _this2.subscribers[id].onMicrophoneAvailabilityChange;
                    onMicrophoneAvailabilityChange(isMicrophoneAvailable);
                });
            }
        },
        {
            key: "emitTranscriptChange",
            value: function emitTranscriptChange(interimTranscript, finalTranscript) {
                var _this3 = this;
                Object.keys(this.subscribers).forEach(function(id) {
                    var onTranscriptChange = _this3.subscribers[id].onTranscriptChange;
                    onTranscriptChange(interimTranscript, finalTranscript);
                });
            }
        },
        {
            key: "emitClearTranscript",
            value: function emitClearTranscript() {
                var _this4 = this;
                Object.keys(this.subscribers).forEach(function(id) {
                    var onClearTranscript = _this4.subscribers[id].onClearTranscript;
                    onClearTranscript();
                });
            }
        },
        {
            key: "emitBrowserSupportsSpeechRecognitionChange",
            value: function emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {
                var _this5 = this;
                Object.keys(this.subscribers).forEach(function(id) {
                    var _this5$subscribers$id = _this5.subscribers[id], onBrowserSupportsSpeechRecognitionChange = _this5$subscribers$id.onBrowserSupportsSpeechRecognitionChange, onBrowserSupportsContinuousListeningChange = _this5$subscribers$id.onBrowserSupportsContinuousListeningChange;
                    onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);
                    onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);
                });
            }
        },
        {
            key: "disconnect",
            value: function disconnect(disconnectType) {
                if (this.recognition && this.listening) {
                    switch(disconnectType){
                        case 'ABORT':
                            this.pauseAfterDisconnect = true;
                            this.abort();
                            break;
                        case 'RESET':
                            this.pauseAfterDisconnect = false;
                            this.abort();
                            break;
                        case 'STOP':
                        default:
                            this.pauseAfterDisconnect = true;
                            this.stop();
                    }
                }
            }
        },
        {
            key: "disableRecognition",
            value: function disableRecognition() {
                if (this.recognition) {
                    this.recognition.onresult = function() {};
                    this.recognition.onend = function() {};
                    this.recognition.onerror = function() {};
                    if (this.listening) {
                        this.stopListening();
                    }
                }
            }
        },
        {
            key: "onError",
            value: function onError(event) {
                if (event && event.error && event.error === 'not-allowed') {
                    this.emitMicrophoneAvailabilityChange(false);
                    this.disableRecognition();
                }
            }
        },
        {
            key: "onRecognitionDisconnect",
            value: function onRecognitionDisconnect() {
                this.onStopListening();
                this.listening = false;
                if (this.pauseAfterDisconnect) {
                    this.emitListeningChange(false);
                } else if (this.recognition) {
                    if (this.recognition.continuous) {
                        this.startListening({
                            continuous: this.recognition.continuous
                        });
                    } else {
                        this.emitListeningChange(false);
                    }
                }
                this.pauseAfterDisconnect = false;
            }
        },
        {
            key: "updateTranscript",
            value: function updateTranscript(_ref) {
                var results = _ref.results, resultIndex = _ref.resultIndex;
                var currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;
                this.interimTranscript = '';
                this.finalTranscript = '';
                for(var i = currentIndex; i < results.length; ++i){
                    if (results[i].isFinal && (!(0, _isAndroid["default"])() || results[i][0].confidence > 0)) {
                        this.updateFinalTranscript(results[i][0].transcript);
                    } else {
                        this.interimTranscript = (0, _utils.concatTranscripts)(this.interimTranscript, results[i][0].transcript);
                    }
                }
                var isDuplicateResult = false;
                if (this.interimTranscript === '' && this.finalTranscript !== '') {
                    if (this.previousResultWasFinalOnly) {
                        isDuplicateResult = true;
                    }
                    this.previousResultWasFinalOnly = true;
                } else {
                    this.previousResultWasFinalOnly = false;
                }
                if (!isDuplicateResult) {
                    this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);
                }
            }
        },
        {
            key: "updateFinalTranscript",
            value: function updateFinalTranscript(newFinalTranscript) {
                this.finalTranscript = (0, _utils.concatTranscripts)(this.finalTranscript, newFinalTranscript);
            }
        },
        {
            key: "resetTranscript",
            value: function resetTranscript() {
                this.disconnect('RESET');
            }
        },
        {
            key: "startListening",
            value: function() {
                var _startListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {
                    var _ref2, _ref2$continuous, continuous, language, isContinuousChanged, isLanguageChanged, _args = arguments;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                        while(1){
                            switch(_context.prev = _context.next){
                                case 0:
                                    _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref2$continuous = _ref2.continuous, continuous = _ref2$continuous === void 0 ? false : _ref2$continuous, language = _ref2.language;
                                    if (this.recognition) {
                                        _context.next = 3;
                                        break;
                                    }
                                    return _context.abrupt("return");
                                case 3:
                                    isContinuousChanged = continuous !== this.recognition.continuous;
                                    isLanguageChanged = language && language !== this.recognition.lang;
                                    if (!(isContinuousChanged || isLanguageChanged)) {
                                        _context.next = 11;
                                        break;
                                    }
                                    if (!this.listening) {
                                        _context.next = 9;
                                        break;
                                    }
                                    _context.next = 9;
                                    return this.stopListening();
                                case 9:
                                    this.recognition.continuous = isContinuousChanged ? continuous : this.recognition.continuous;
                                    this.recognition.lang = isLanguageChanged ? language : this.recognition.lang;
                                case 11:
                                    if (this.listening) {
                                        _context.next = 22;
                                        break;
                                    }
                                    if (!this.recognition.continuous) {
                                        this.resetTranscript();
                                        this.emitClearTranscript();
                                    }
                                    _context.prev = 13;
                                    _context.next = 16;
                                    return this.start();
                                case 16:
                                    this.emitListeningChange(true);
                                    _context.next = 22;
                                    break;
                                case 19:
                                    _context.prev = 19;
                                    _context.t0 = _context["catch"](13);
                                    // DOMExceptions indicate a redundant microphone start - safe to swallow
                                    if (!(_context.t0 instanceof DOMException)) {
                                        this.emitMicrophoneAvailabilityChange(false);
                                    }
                                case 22:
                                case "end":
                                    return _context.stop();
                            }
                        }
                    }, _callee, this, [
                        [
                            13,
                            19
                        ]
                    ]);
                }));
                function startListening() {
                    return _startListening.apply(this, arguments);
                }
                return startListening;
            }()
        },
        {
            key: "abortListening",
            value: function() {
                var _abortListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {
                    var _this6 = this;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while(1){
                            switch(_context2.prev = _context2.next){
                                case 0:
                                    this.disconnect('ABORT');
                                    this.emitListeningChange(false);
                                    _context2.next = 4;
                                    return new Promise(function(resolve) {
                                        _this6.onStopListening = resolve;
                                    });
                                case 4:
                                case "end":
                                    return _context2.stop();
                            }
                        }
                    }, _callee2, this);
                }));
                function abortListening() {
                    return _abortListening.apply(this, arguments);
                }
                return abortListening;
            }()
        },
        {
            key: "stopListening",
            value: function() {
                var _stopListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3() {
                    var _this7 = this;
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                        while(1){
                            switch(_context3.prev = _context3.next){
                                case 0:
                                    this.disconnect('STOP');
                                    this.emitListeningChange(false);
                                    _context3.next = 4;
                                    return new Promise(function(resolve) {
                                        _this7.onStopListening = resolve;
                                    });
                                case 4:
                                case "end":
                                    return _context3.stop();
                            }
                        }
                    }, _callee3, this);
                }));
                function stopListening() {
                    return _stopListening.apply(this, arguments);
                }
                return stopListening;
            }()
        },
        {
            key: "getRecognition",
            value: function getRecognition() {
                return this.recognition;
            }
        },
        {
            key: "start",
            value: function() {
                var _start = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee4() {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while(1){
                            switch(_context4.prev = _context4.next){
                                case 0:
                                    if (!(this.recognition && !this.listening)) {
                                        _context4.next = 4;
                                        break;
                                    }
                                    _context4.next = 3;
                                    return this.recognition.start();
                                case 3:
                                    this.listening = true;
                                case 4:
                                case "end":
                                    return _context4.stop();
                            }
                        }
                    }, _callee4, this);
                }));
                function start() {
                    return _start.apply(this, arguments);
                }
                return start;
            }()
        },
        {
            key: "stop",
            value: function stop() {
                if (this.recognition && this.listening) {
                    this.recognition.stop();
                    this.listening = false;
                }
            }
        },
        {
            key: "abort",
            value: function abort() {
                if (this.recognition && this.listening) {
                    this.recognition.abort();
                    this.listening = false;
                }
            }
        }
    ]);
    return RecognitionManager;
}();
exports["default"] = RecognitionManager;
}}),
"[project]/node_modules/react-speech-recognition/lib/SpeechRecognition.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = exports.useSpeechRecognition = void 0;
var _react = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _utils = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/utils.js [app-ssr] (ecmascript)");
var _actions = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/actions.js [app-ssr] (ecmascript)");
var _reducers = __turbopack_require__("[project]/node_modules/react-speech-recognition/lib/reducers.js [app-ssr] (ecmascript)");
var _RecognitionManager = _interopRequireDefault(__turbopack_require__("[project]/node_modules/react-speech-recognition/lib/RecognitionManager.js [app-ssr] (ecmascript)"));
var _isAndroid = _interopRequireDefault(__turbopack_require__("[project]/node_modules/react-speech-recognition/lib/isAndroid.js [app-ssr] (ecmascript)"));
var _NativeSpeechRecognition = _interopRequireDefault(__turbopack_require__("[project]/node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var _browserSupportsSpeechRecognition = !!_NativeSpeechRecognition["default"];
var _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !(0, _isAndroid["default"])();
var recognitionManager;
var useSpeechRecognition = function useSpeechRecognition() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$transcribing = _ref.transcribing, transcribing = _ref$transcribing === void 0 ? true : _ref$transcribing, _ref$clearTranscriptO = _ref.clearTranscriptOnListen, clearTranscriptOnListen = _ref$clearTranscriptO === void 0 ? true : _ref$clearTranscriptO, _ref$commands = _ref.commands, commands = _ref$commands === void 0 ? [] : _ref$commands;
    var _useState = (0, _react.useState)(SpeechRecognition.getRecognitionManager()), _useState2 = _slicedToArray(_useState, 1), recognitionManager = _useState2[0];
    var _useState3 = (0, _react.useState)(_browserSupportsSpeechRecognition), _useState4 = _slicedToArray(_useState3, 2), browserSupportsSpeechRecognition = _useState4[0], setBrowserSupportsSpeechRecognition = _useState4[1];
    var _useState5 = (0, _react.useState)(_browserSupportsContinuousListening), _useState6 = _slicedToArray(_useState5, 2), browserSupportsContinuousListening = _useState6[0], setBrowserSupportsContinuousListening = _useState6[1];
    var _useReducer = (0, _react.useReducer)(_reducers.transcriptReducer, {
        interimTranscript: recognitionManager.interimTranscript,
        finalTranscript: ''
    }), _useReducer2 = _slicedToArray(_useReducer, 2), _useReducer2$ = _useReducer2[0], interimTranscript = _useReducer2$.interimTranscript, finalTranscript = _useReducer2$.finalTranscript, dispatch = _useReducer2[1];
    var _useState7 = (0, _react.useState)(recognitionManager.listening), _useState8 = _slicedToArray(_useState7, 2), listening = _useState8[0], setListening = _useState8[1];
    var _useState9 = (0, _react.useState)(recognitionManager.isMicrophoneAvailable), _useState10 = _slicedToArray(_useState9, 2), isMicrophoneAvailable = _useState10[0], setMicrophoneAvailable = _useState10[1];
    var commandsRef = (0, _react.useRef)(commands);
    commandsRef.current = commands;
    var dispatchClearTranscript = function dispatchClearTranscript() {
        dispatch((0, _actions.clearTranscript)());
    };
    var resetTranscript = (0, _react.useCallback)(function() {
        recognitionManager.resetTranscript();
        dispatchClearTranscript();
    }, [
        recognitionManager
    ]);
    var testFuzzyMatch = function testFuzzyMatch(command, input, fuzzyMatchingThreshold) {
        var commandToString = _typeof(command) === 'object' ? command.toString() : command;
        var commandWithoutSpecials = commandToString.replace(/[&/\\#,+()!$~%.'":*?<>{}]/g, '').replace(/  +/g, ' ').trim();
        var howSimilar = (0, _utils.compareTwoStringsUsingDiceCoefficient)(commandWithoutSpecials, input);
        if (howSimilar >= fuzzyMatchingThreshold) {
            return {
                command: command,
                commandWithoutSpecials: commandWithoutSpecials,
                howSimilar: howSimilar,
                isFuzzyMatch: true
            };
        }
        return null;
    };
    var testMatch = function testMatch(command, input) {
        var pattern = (0, _utils.commandToRegExp)(command);
        var result = pattern.exec(input);
        if (result) {
            return {
                command: command,
                parameters: result.slice(1)
            };
        }
        return null;
    };
    var matchCommands = (0, _react.useCallback)(function(newInterimTranscript, newFinalTranscript) {
        commandsRef.current.forEach(function(_ref2) {
            var command = _ref2.command, callback = _ref2.callback, _ref2$matchInterim = _ref2.matchInterim, matchInterim = _ref2$matchInterim === void 0 ? false : _ref2$matchInterim, _ref2$isFuzzyMatch = _ref2.isFuzzyMatch, isFuzzyMatch = _ref2$isFuzzyMatch === void 0 ? false : _ref2$isFuzzyMatch, _ref2$fuzzyMatchingTh = _ref2.fuzzyMatchingThreshold, fuzzyMatchingThreshold = _ref2$fuzzyMatchingTh === void 0 ? 0.8 : _ref2$fuzzyMatchingTh, _ref2$bestMatchOnly = _ref2.bestMatchOnly, bestMatchOnly = _ref2$bestMatchOnly === void 0 ? false : _ref2$bestMatchOnly;
            var input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();
            var subcommands = Array.isArray(command) ? command : [
                command
            ];
            var results = subcommands.map(function(subcommand) {
                if (isFuzzyMatch) {
                    return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);
                }
                return testMatch(subcommand, input);
            }).filter(function(x) {
                return x;
            });
            if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {
                results.sort(function(a, b) {
                    return b.howSimilar - a.howSimilar;
                });
                var _results$ = results[0], _command = _results$.command, commandWithoutSpecials = _results$.commandWithoutSpecials, howSimilar = _results$.howSimilar;
                callback(commandWithoutSpecials, input, howSimilar, {
                    command: _command,
                    resetTranscript: resetTranscript
                });
            } else {
                results.forEach(function(result) {
                    if (result.isFuzzyMatch) {
                        var _command2 = result.command, _commandWithoutSpecials = result.commandWithoutSpecials, _howSimilar = result.howSimilar;
                        callback(_commandWithoutSpecials, input, _howSimilar, {
                            command: _command2,
                            resetTranscript: resetTranscript
                        });
                    } else {
                        var _command3 = result.command, parameters = result.parameters;
                        callback.apply(void 0, _toConsumableArray(parameters).concat([
                            {
                                command: _command3,
                                resetTranscript: resetTranscript
                            }
                        ]));
                    }
                });
            }
        });
    }, [
        resetTranscript
    ]);
    var handleTranscriptChange = (0, _react.useCallback)(function(newInterimTranscript, newFinalTranscript) {
        if (transcribing) {
            dispatch((0, _actions.appendTranscript)(newInterimTranscript, newFinalTranscript));
        }
        matchCommands(newInterimTranscript, newFinalTranscript);
    }, [
        matchCommands,
        transcribing
    ]);
    var handleClearTranscript = (0, _react.useCallback)(function() {
        if (clearTranscriptOnListen) {
            dispatchClearTranscript();
        }
    }, [
        clearTranscriptOnListen
    ]);
    (0, _react.useEffect)(function() {
        var id = SpeechRecognition.counter;
        SpeechRecognition.counter += 1;
        var callbacks = {
            onListeningChange: setListening,
            onMicrophoneAvailabilityChange: setMicrophoneAvailable,
            onTranscriptChange: handleTranscriptChange,
            onClearTranscript: handleClearTranscript,
            onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,
            onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening
        };
        recognitionManager.subscribe(id, callbacks);
        return function() {
            recognitionManager.unsubscribe(id);
        };
    }, [
        transcribing,
        clearTranscriptOnListen,
        recognitionManager,
        handleTranscriptChange,
        handleClearTranscript
    ]);
    var transcript = (0, _utils.concatTranscripts)(finalTranscript, interimTranscript);
    return {
        transcript: transcript,
        interimTranscript: interimTranscript,
        finalTranscript: finalTranscript,
        listening: listening,
        isMicrophoneAvailable: isMicrophoneAvailable,
        resetTranscript: resetTranscript,
        browserSupportsSpeechRecognition: browserSupportsSpeechRecognition,
        browserSupportsContinuousListening: browserSupportsContinuousListening
    };
};
exports.useSpeechRecognition = useSpeechRecognition;
var SpeechRecognition = {
    counter: 0,
    applyPolyfill: function applyPolyfill(PolyfillSpeechRecognition) {
        if (recognitionManager) {
            recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);
        } else {
            recognitionManager = new _RecognitionManager["default"](PolyfillSpeechRecognition);
        }
        var browserSupportsPolyfill = !!PolyfillSpeechRecognition && (0, _utils.browserSupportsPolyfills)();
        _browserSupportsSpeechRecognition = browserSupportsPolyfill;
        _browserSupportsContinuousListening = browserSupportsPolyfill;
    },
    removePolyfill: function removePolyfill() {
        if (recognitionManager) {
            recognitionManager.setSpeechRecognition(_NativeSpeechRecognition["default"]);
        } else {
            recognitionManager = new _RecognitionManager["default"](_NativeSpeechRecognition["default"]);
        }
        _browserSupportsSpeechRecognition = !!_NativeSpeechRecognition["default"];
        _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !(0, _isAndroid["default"])();
    },
    getRecognitionManager: function getRecognitionManager() {
        if (!recognitionManager) {
            recognitionManager = new _RecognitionManager["default"](_NativeSpeechRecognition["default"]);
        }
        return recognitionManager;
    },
    getRecognition: function getRecognition() {
        var recognitionManager = SpeechRecognition.getRecognitionManager();
        return recognitionManager.getRecognition();
    },
    startListening: function() {
        var _startListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {
            var _ref3, continuous, language, recognitionManager, _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
                while(1){
                    switch(_context.prev = _context.next){
                        case 0:
                            _ref3 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, continuous = _ref3.continuous, language = _ref3.language;
                            recognitionManager = SpeechRecognition.getRecognitionManager();
                            _context.next = 4;
                            return recognitionManager.startListening({
                                continuous: continuous,
                                language: language
                            });
                        case 4:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee);
        }));
        function startListening() {
            return _startListening.apply(this, arguments);
        }
        return startListening;
    }(),
    stopListening: function() {
        var _stopListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {
            var recognitionManager;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while(1){
                    switch(_context2.prev = _context2.next){
                        case 0:
                            recognitionManager = SpeechRecognition.getRecognitionManager();
                            _context2.next = 3;
                            return recognitionManager.stopListening();
                        case 3:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2);
        }));
        function stopListening() {
            return _stopListening.apply(this, arguments);
        }
        return stopListening;
    }(),
    abortListening: function() {
        var _abortListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3() {
            var recognitionManager;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while(1){
                    switch(_context3.prev = _context3.next){
                        case 0:
                            recognitionManager = SpeechRecognition.getRecognitionManager();
                            _context3.next = 3;
                            return recognitionManager.abortListening();
                        case 3:
                        case "end":
                            return _context3.stop();
                    }
                }
            }, _callee3);
        }));
        function abortListening() {
            return _abortListening.apply(this, arguments);
        }
        return abortListening;
    }(),
    browserSupportsSpeechRecognition: function browserSupportsSpeechRecognition() {
        return _browserSupportsSpeechRecognition;
    },
    browserSupportsContinuousListening: function browserSupportsContinuousListening() {
        return _browserSupportsContinuousListening;
    }
};
var _default = SpeechRecognition;
exports["default"] = _default;
}}),
"[project]/node_modules/react-speech-recognition/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useSpeechRecognition", {
    enumerable: true,
    get: function get() {
        return _SpeechRecognition.useSpeechRecognition;
    }
});
exports["default"] = void 0;
var _SpeechRecognition = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/react-speech-recognition/lib/SpeechRecognition.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
    };
    return cache;
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
            "default": obj
        };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj["default"] = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
var _default = _SpeechRecognition["default"];
exports["default"] = _default;
}}),

};

//# sourceMappingURL=node_modules_eca77e._.js.map